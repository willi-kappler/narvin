TODO:

- Refactor code to make it testable.
- Then write test cases.
- Use compiler options: --styleCheck:usages --styleCheck:error
- Share optimal solutions between different servers.
- Refactor: individual1.fitness < individual2.fitness to individual1 < individual2


- Try out different random number generators:
  https://github.com/oprypin/nim-random
  https://github.com/IcedQuinn/splitmix64
  https://de.wikipedia.org/wiki/Xorshift
  https://de.wikipedia.org/wiki/Multiply-with-carry#Complimentary_Multiply-with-carry
  https://de.wikipedia.org/wiki/Well_Equidistributed_Long-period_Linear

  https://github.com/obsidiandynamics/tinyrand
  https://github.com/Absolucy/nanorand-rs
  https://hg.sr.ht/~icefox/oorandom/browse/src/lib.rs?rev=tip
  https://github.com/rust-random/rand?tab=readme-ov-file






Done:

- Add a first implementation.
- Add a first example.
- Add na_population, refactor na_population_node 1 to 3.
- Add option for random amount of mutation: let m = rand(self.numOfMutations - 1) + 1.
- Allow to use just one set of mutation operation for one population.
- Add option to always send the best global individual to each population
- Allow to load saved individuals at startup.


